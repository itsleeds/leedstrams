---
format: gfm
execute: 
  echo: false
---

## Preprocessing

```{r}
library(sf)
library(terra)
library(glue)

# Keep this document cheap to render:
# - Prefer small, local computations
# - Limit remote tile downloads to a handful (<= 10)

# Optional: a quick Leeds boundary for experimentation (not essential for tile examples)
leeds_boundary <- NULL
if (requireNamespace("zonebuilder", quietly = TRUE)) {
  leeds_boundary <- zonebuilder::zb_zone("Leeds", n_circles = 1)
}
```

### Plan

-   Download the town map dataset from Scottish Library: https://maps.nls.uk/os/townplans-england/leeds2.html
-   Digitise the tramway centerlines from there
-   Digitise the tram network from Alex's image data
-   Combine both datasets into a single tramway network
-   Bonus: track lines
-   Comparing with OSM

### Rail Map online data

![](images/paste-2.png)

See png-to-geojson.py

### Town plan data

Individuals tiles can be accessed from URLs such as https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/19/259898/168840.png

This is raster 'tile pyramids' - zoom level 19, tile coordinates 259898, 168840.

<!-- We can import this image (single tile): -->

```{r}
#| eval: false
u = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/19/259898/168840.png"
img = magick::image_read(u)
# # A tibble: 1 Ã— 7
#   format width height colorspace matte filesize density
#   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>
# 1 PNG      256    256 sRGB       FALSE    54128 72x72
img_terra = terra::rast(u)
# Calculate extent based on XYZ tile coordinates (Web Mercator)
z <- 19
x <- 259898
y <- 168840
max_ext <- 20037508.34
tile_size <- (2 * max_ext) / (2^z)

xmin <- -max_ext + (x * tile_size)
xmax <- -max_ext + ((x + 1) * tile_size)
ymax <- max_ext - (y * tile_size)
ymin <- max_ext - ((y + 1) * tile_size)

terra::ext(img_terra) <- c(xmin, xmax, ymin, ymax)
terra::crs(img_terra) <- "EPSG:3857"
terra::plotRGB(img_terra)
mapview::mapview(img_terra)
```

We can put that logic into a small set of helpers:

- Convert lon/lat to XYZ tile coords (and back)
- Download a tile and set its Web Mercator extent
- Convert NLS paletted PNG tiles to RGB so plotting works

```{r}
#| label: download-tiles
tile_coords_to_xy <- function(lon, lat, z, scheme = c("xyz", "tms")) {
  scheme <- match.arg(scheme)
  stopifnot(is.finite(lon), is.finite(lat), is.finite(z))

  n <- 2^z

  # Web Mercator latitude limit (prevents Inf from tan/log near the poles)
  lat <- max(min(lat, 85.05112878), -85.05112878)
  lat_rad <- lat * pi / 180

  x_tile <- floor((lon + 180) / 360 * n)
  y_tile <- floor((1 - log(tan(lat_rad) + 1 / cos(lat_rad)) / pi) / 2 * n)

  # Clamp to valid range [0, n - 1]
  x_tile <- max(min(x_tile, n - 1), 0)
  y_tile <- max(min(y_tile, n - 1), 0)

  if (scheme == "tms") {
    y_tile <- (n - 1) - y_tile
  }

  c(x = x_tile, y = y_tile)
}

tile_xy_to_lonlat <- function(x, y, z, scheme = c("xyz", "tms"), offset = 0.5) {
  scheme <- match.arg(scheme)
  stopifnot(is.finite(x), is.finite(y), is.finite(z), is.finite(offset))

  n <- 2^z
  if (scheme == "tms") y <- (n - 1) - y

  lon <- ((x + offset) / n) * 360 - 180
  lat_rad <- atan(sinh(pi * (1 - 2 * (y + offset) / n)))
  lat <- lat_rad * 180 / pi

  c(lon = lon, lat = lat)
}

tile_terra_zxy <- function(
    base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North",
    z,
    x,
    y
  ) {
  u <- glue("{base_url}/{z}/{x}/{y}.png")
  r <- suppressWarnings(terra::rast(u))

  # NLS tiles are paletted PNGs (single band + color table). Convert to RGB so
  # plotRGB()/mapview render real colours (not a false palette).
  if (terra::nlyr(r) == 1 && terra::has.colors(r)) {
    ct <- terra::coltab(r)[[1]]
    rR <- terra::subst(r, ct$value, ct$red)
    rG <- terra::subst(r, ct$value, ct$green)
    rB <- terra::subst(r, ct$value, ct$blue)
    r <- c(rR, rG, rB)
    terra::RGB(r) <- 1:3
  }

  # Web tiles are stored with a top-left origin; flip so north is up.
  r <- terra::flip(r, direction = "vertical")

  max_ext <- 20037508.34
  tile_size <- (2 * max_ext) / (2^z)

  xmin <- -max_ext + (x * tile_size)
  xmax <- -max_ext + ((x + 1) * tile_size)
  ymax <- max_ext - (y * tile_size)
  ymin <- max_ext - ((y + 1) * tile_size)

  terra::ext(r) <- c(xmin, xmax, ymin, ymax)
  terra::crs(r) <- "EPSG:3857"
  r
}

tile_tiles_near_lonlat <- function(lon, lat, z, n_tiles = 3) {
  n_tiles <- as.integer(n_tiles)
  stopifnot(n_tiles >= 1)

  xy0 <- tile_coords_to_xy(lon, lat, z = z, scheme = "xyz")
  x0 <- as.integer(xy0["x"])
  y0 <- as.integer(xy0["y"])

  # Prefer footprints that don't create large NA gaps in the merged raster.
  # - n_tiles==3: use a contiguous 1x3 strip
  # - n_tiles==4: use a contiguous 2x2 block
  if (n_tiles == 1) {
    offsets <- data.frame(dx = 0, dy = 0)
  } else if (n_tiles == 2) {
    offsets <- data.frame(dx = c(-1, 0), dy = c(0, 0))
  } else if (n_tiles == 3) {
    offsets <- data.frame(dx = c(-1, 0, 1), dy = c(0, 0, 0))
  } else if (n_tiles == 4) {
    offsets <- expand.grid(dx = c(-1, 0), dy = c(-1, 0))
  } else {
    side <- ceiling(sqrt(n_tiles))
    dx_range <- (-floor(side / 2)):(ceiling(side / 2) - 1)
    dy_range <- (-floor(side / 2)):(ceiling(side / 2) - 1)
    offsets <- expand.grid(dx = dx_range, dy = dy_range)
    offsets <- offsets[order(offsets$dx^2 + offsets$dy^2, abs(offsets$dx), abs(offsets$dy)), ]
    offsets <- head(offsets, n_tiles)
  }

  transform(offsets, x = x0 + dx, y = y0 + dy)[, c("x", "y")]
}

tile_terra_lonlat <- function(
    base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North",
    z,
    lon,
    lat
  ) {
  xy <- tile_coords_to_xy(lon, lat, z = z, scheme = "xyz")
  tile_terra_zxy(base_url = base_url, z = z, x = xy["x"], y = xy["y"])
}

# Quick, deterministic test for tile coord logic:
# Use the *center* of a known tile, then it must round-trip to the same x/y.
expected_x <- 519739
expected_y <- 337593
center <- tile_xy_to_lonlat(expected_x, expected_y, z = 20, scheme = "xyz", offset = 0.5)
stopifnot(all(tile_coords_to_xy(center["lon"], center["lat"], z = 20) == c(x = expected_x, y = expected_y)))
```

# Download a small mosaic near Hyde Park (cheap: <= 10 tiles)

```{r}
#| label: hyde-park-mosaic
#| fig-asp: 1
#| fig-width: 8
#| fig-height: 8
#| fig-dpi: 200
base_url <- "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North"
z <- 20
hyde_park <- c(lon = -1.561482, lat = 53.814711)
n_tiles <- 4
n_tiles <- min(n_tiles, 10)

tiles <- tile_tiles_near_lonlat(hyde_park["lon"], hyde_park["lat"], z = z, n_tiles = n_tiles)
print(tiles)

r_list <- Map(
  function(x, y) tile_terra_zxy(base_url = base_url, z = z, x = x, y = y),
  tiles$x,
  tiles$y
)

leeds_tiles <- terra::merge(terra::sprc(r_list))

# Render a quick preview (Web Mercator) in black-and-white
# (convert RGB -> grayscale luminance)
leeds_tiles_bw <- terra::app(leeds_tiles, fun = function(v) {
  0.299 * v[1] + 0.587 * v[2] + 0.114 * v[3]
})

op <- par(no.readonly = TRUE)
par(mar = c(0, 0, 0, 0))
terra::plot(
  leeds_tiles_bw,
  col = gray.colors(256, start = 0, end = 1),
  axes = FALSE,
  box = FALSE
)
par(op)

# Optional: British National Grid export
# (keep eval cheap; uncomment if you need a GeoTIFF on disk)
# leeds_tiles_bn <- terra::project(leeds_tiles, "EPSG:27700")
# terra::writeRaster(leeds_tiles_bn, "leeds_townplan.tif", overwrite = TRUE)

if (interactive() && requireNamespace("mapview", quietly = TRUE)) {
  mapview::mapview(leeds_tiles)
}
```

The general pattern is: https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png

You can copy-paste that URL into QGIS 'XYZ Tiles' to access the tiles directly as shown below:

![](images/paste-1.png)

<!-- You can download the tiles using R as follows: -->

```{r}


```

```{r}
#| eval: false
# Note: failed
library(maptiles)
# Define the tile provider
nls_provider <- create_provider(
  name = "NLS_Town_Plans",
  url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png",
  citation = "National Library of Scotland"
)
central_leeds = leeds_boundary |>
  st_transform(27700) 

mapview::mapview(central_leeds)

# Get tiles
leeds_tiles <- get_tiles(
  x = central_leeds, 
  provider = nls_provider, 
  zoom = 11,
  crop = TRUE,
  cachedir = "./tiles"
)
list.files("./tiles")
# Plot tiles
plot_tiles(leeds_tiles)
```

You can also use the `ceramic` package to download tiles:

```{r}
#| label: ceramic-tiles
#| eval: false
library(ceramic)

# Get tiles for Leeds boundary
# Note: This requires a Mapbox API key to be set in the environment variable MAPBOX_API_KEY
# Sys.setenv(MAPBOX_API_KEY = "your_key_here")

# cc_location automatically selects a zoom level based on the extent
# We use the leeds_boundary object defined earlier
leeds_tiles_ceramic <- cc_location(leeds_boundary)

# Plot
if(requireNamespace("terra", quietly = TRUE)) {
  terra::plotRGB(leeds_tiles_ceramic)
  plot(st_geometry(leeds_boundary), add = TRUE, border = "red")
}

tiles = read_tiles(
  x = central_leeds,
  base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/",
  zoom = 19
)
```

### Extracting tram network from image

The following Python code processes the image `images/paste-2.png` to extract the Leeds tram network lines (purple), skeletonizes them, and converts the result to LineStrings.

```{python}
#| label: extract-tram-network
#| eval: false
import cv2
import numpy as np
from skimage.morphology import skeletonize
from shapely.geometry import LineString
import geopandas as gpd
import matplotlib.pyplot as plt

# Load the image
image_path = 'images/paste-2.png'
img = cv2.imread(image_path)

if img is not None:
    # Convert to HSV color space
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Define color range for the Leeds tram network (purple/blue lines)
    # Note: These values are approximate and may need tuning based on the specific image
    # HSV range: Hue [0, 179], Saturation [0, 255], Value [0, 255]
    # Purple is roughly around 130-160 in OpenCV's Hue scale
    lower_purple = np.array([120, 50, 50])
    upper_purple = np.array([170, 255, 255])

    # Create a mask
    mask = cv2.inRange(hsv, lower_purple, upper_purple)

    # Skeletonize the mask (requires boolean input)
    # We divide by 255 to get 0/1 values
    skeleton = skeletonize(mask // 255)

    # Convert skeleton to vector representation (LineStrings)
    # This is a simplified approach using contours
    contours, _ = cv2.findContours(skeleton.astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

    lines = []
    for cnt in contours:
        # Contours are arrays of points (x, y)
        # We need at least 2 points to form a LineString
        if len(cnt) >= 2:
            points = cnt.squeeze().tolist()
            # Handle case where squeeze results in 1D array if only 1 point (though len check handles most)
            if isinstance(points, list) and len(points) >= 2 and isinstance(points[0], list):
                 lines.append(LineString(points))
            elif isinstance(points, list) and len(points) >= 2 and isinstance(points[0], (int, float)):
                 # Case with 2 points, squeeze might return list of lists or flat list depending on shape
                 # cnt shape is (N, 1, 2). squeeze -> (N, 2).
                 # If N=2, squeeze -> (2, 2).
                 lines.append(LineString(points))

    # Create a GeoDataFrame
    gdf = gpd.GeoDataFrame(geometry=lines)

    # Plotting for verification
    fig, ax = plt.subplots(1, 2, figsize=(12, 6))
    ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    ax[0].set_title('Original Image')
    ax[1].imshow(skeleton, cmap='gray')
    ax[1].set_title('Skeletonized Network')
    plt.show()

    # Save to file (optional)
    # gdf.to_file("leeds_tram_skeleton.geojson", driver="GeoJSON")
else:
    print(f"Image not found at {image_path}")
```

## Research

-   Compare with historic economic and usage data
-   ...