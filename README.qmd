---
format: gfm
execute: 
  echo: false
---

# `leedstrams`

This repository is an R package that provides helpers for working with the National Library of Scotland (NLS) OS town-plan *XYZ tile pyramids*, used for the Leeds tram mapping case study.

## Install

```{r}
#| eval: false
# install.packages("remotes")
remotes::install_github("itsleeds/leedstrams")
```

## Core package functions

Tile maths:

-   `tile_coords_to_xy()` (lon/lat -\> x/y)
-   `tile_xy_to_lonlat()` (x/y -\> lon/lat)
-   `tile_webmerc_extent()` (tile -\> EPSG:3857 extent)

NLS tile access:

-   `nls_tile_rast_zxy()` (read a z/x/y tile into a georeferenced `terra` raster)
-   `nls_tile_rast_lonlat()` (read the tile containing a lon/lat)

Tile selection:

-   `nls_tiles_near_lonlat()` (compact set of nearby tiles, useful for small mosaics)
-   `nls_tiles_for_polygon()` (tile indices intersecting an `sf` polygon)

## Example: small mosaic near Hyde Park

```{r}
#| eval: false
library(leedstrams)
library(terra)

base_url <- "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North"
z <- 20
hyde_park <- c(lon = -1.561482, lat = 53.814711)

tiles <- nls_tiles_near_lonlat(hyde_park["lon"], hyde_park["lat"], z = z, n_tiles = 4)
r_list <- Map(
  function(x, y) nls_tile_rast_zxy(base_url = base_url, z = z, x = x, y = y),
  tiles$x,
  tiles$y
)
mosaic <- terra::merge(terra::sprc(r_list))
terra::plotRGB(mosaic)
```

## Downloading/stitching a larger Leeds mosaic

For a reproducible end-to-end download/stitch workflow (including chunked merging), see the standalone script:

-   `scripts/download_leeds_nls_tiles.R`

That script caches downloaded tiles under `.cache/` and writes `tiles_merged_leeds.tif` (these outputs are gitignored).

You can download a [100MB file with all of the tiles in a 1km radius of central Leeds from the releases of this repo](https://github.com/itsleeds/leedstrams/releases/tag/v1) and open up in QGIS or similar as shown below:

![](images/paste-3.png)

## Documentation

-   User vignette: `vignettes/nls-tiles.Rmd`
-   pkgdown site: https://itsleeds.github.io/leedstrams/
-   Developer-only one-off checks: `dev/tests.Rmd`

## Notes

Keep remote tile downloads limited when rendering documentation, and prefer running larger downloads via the script above.

### Plan

-   Download the town map dataset from Scottish Library: https://maps.nls.uk/os/townplans-england/leeds2.html
-   Digitise the tramway centerlines from there
-   Digitise the tram network from Alex's image data
-   Combine both datasets into a single tramway network
-   Bonus: track lines
-   Comparing with OSM

### Rail Map online data

![](images/paste-2.png)

See png-to-geojson.py

### Town plan data

Individual tiles can be accessed from URLs such as `https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/19/259898/168840.png`.

This is a raster tile pyramid: zoom level 19, tile coordinates 259898, 168840.

The general pattern is: `https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png`

You can copy-paste that URL into QGIS 'XYZ Tiles' to access the tiles directly as shown below:

![](images/paste-1.png)

<!-- You can download the tiles using R as follows: -->

```{r}


```

```{r}
#| eval: false
# Note: failed
library(maptiles)
# Define the tile provider
nls_provider <- create_provider(
  name = "NLS_Town_Plans",
  url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png",
  citation = "National Library of Scotland"
)
central_leeds = leeds_boundary |>
  st_transform(27700) 

mapview::mapview(central_leeds)

# Get tiles
leeds_tiles <- get_tiles(
  x = central_leeds, 
  provider = nls_provider, 
  zoom = 11,
  crop = TRUE,
  cachedir = "./tiles"
)
list.files("./tiles")
# Plot tiles
plot_tiles(leeds_tiles)
```

You can also use the `ceramic` package to download tiles:

```{r}
#| label: ceramic-tiles
#| eval: false
library(ceramic)

# Get tiles for Leeds boundary
# Note: This requires a Mapbox API key to be set in the environment variable MAPBOX_API_KEY
# Sys.setenv(MAPBOX_API_KEY = "your_key_here")

# cc_location automatically selects a zoom level based on the extent
# We use the leeds_boundary object defined earlier
leeds_tiles_ceramic <- cc_location(leeds_boundary)

# Plot
if(requireNamespace("terra", quietly = TRUE)) {
  terra::plotRGB(leeds_tiles_ceramic)
  plot(st_geometry(leeds_boundary), add = TRUE, border = "red")
}

tiles = read_tiles(
  x = central_leeds,
  base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/",
  zoom = 19
)
```

### Extracting tram network from image

The following Python code processes the image `images/paste-2.png` to extract the Leeds tram network lines (purple), skeletonizes them, and converts the result to LineStrings.

```{python}
#| label: extract-tram-network
#| eval: false
import cv2
import numpy as np
from skimage.morphology import skeletonize
from shapely.geometry import LineString
import geopandas as gpd
import matplotlib.pyplot as plt

# Load the image
image_path = 'images/paste-2.png'
img = cv2.imread(image_path)

if img is not None:
    # Convert to HSV color space
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Define color range for the Leeds tram network (purple/blue lines)
    # Note: These values are approximate and may need tuning based on the specific image
    # HSV range: Hue [0, 179], Saturation [0, 255], Value [0, 255]
    # Purple is roughly around 130-160 in OpenCV's Hue scale
    lower_purple = np.array([120, 50, 50])
    upper_purple = np.array([170, 255, 255])

    # Create a mask
    mask = cv2.inRange(hsv, lower_purple, upper_purple)

    # Skeletonize the mask (requires boolean input)
    # We divide by 255 to get 0/1 values
    skeleton = skeletonize(mask // 255)

    # Convert skeleton to vector representation (LineStrings)
    # This is a simplified approach using contours
    contours, _ = cv2.findContours(skeleton.astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

    lines = []
    for cnt in contours:
        # Contours are arrays of points (x, y)
        # We need at least 2 points to form a LineString
        if len(cnt) >= 2:
            points = cnt.squeeze().tolist()
            # Handle case where squeeze results in 1D array if only 1 point (though len check handles most)
            if isinstance(points, list) and len(points) >= 2 and isinstance(points[0], list):
                 lines.append(LineString(points))
            elif isinstance(points, list) and len(points) >= 2 and isinstance(points[0], (int, float)):
                 # Case with 2 points, squeeze might return list of lists or flat list depending on shape
                 # cnt shape is (N, 1, 2). squeeze -> (N, 2).
                 # If N=2, squeeze -> (2, 2).
                 lines.append(LineString(points))

    # Create a GeoDataFrame
    gdf = gpd.GeoDataFrame(geometry=lines)

    # Plotting for verification
    fig, ax = plt.subplots(1, 2, figsize=(12, 6))
    ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    ax[0].set_title('Original Image')
    ax[1].imshow(skeleton, cmap='gray')
    ax[1].set_title('Skeletonized Network')
    plt.show()

    # Save to file (optional)
    # gdf.to_file("leeds_tram_skeleton.geojson", driver="GeoJSON")
else:
    print(f"Image not found at {image_path}")
```

## Research

-   Compare with historic economic and usage data
-   ...