---
format: gfm
execute: 
  echo: false
---

## Proprocessing

```{r}
library(tidyverse)
library(sf)
zones = pct::get_pct_zones("west-yorkshire")
zones_leeds = zones |> 
  filter(lad_name == "Leeds")
leeds_boundary_lad = st_union(zones_leeds)
leeds_boundary = leeds_boundary_lad
# For testing:
leeds_boundary = zonebuilder::zb_zone("Leeds", n_circles = 1)
```

### Plan

-   Download the town map dataset from Scottish Library: https://maps.nls.uk/os/townplans-england/leeds2.html
-   Digitise the tramway centerlines from there
-   Digitise the tram network from Alex's image data
-   Combine both datasets into a single tramway network
-   Bonus: track lines
-   Comparing with OSM

### Rail Map online data

![](images/paste-2.png)

See png-to-geojson.py

### Town plan data

Individuals tiles can be accessed from URLs such as https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/19/259898/168840.png

This is raster 'tile pyramids' - zoom level 19, tile coordinates 259898, 168840.

<!-- We can import this image: -->

```{r}
#| eval: false
u = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/19/259898/168840.png"
img = magick::image_read(u)
# # A tibble: 1 Ã— 7
#   format width height colorspace matte filesize density
#   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>
# 1 PNG      256    256 sRGB       FALSE    54128 72x72
img_terra = terra::rast(u)
# Calculate extent based on XYZ tile coordinates (Web Mercator)
z <- 19
x <- 259898
y <- 168840
max_ext <- 20037508.34
tile_size <- (2 * max_ext) / (2^z)

xmin <- -max_ext + (x * tile_size)
xmax <- -max_ext + ((x + 1) * tile_size)
ymax <- max_ext - (y * tile_size)
ymin <- max_ext - ((y + 1) * tile_size)

terra::ext(img_terra) <- c(xmin, xmax, ymin, ymax)
terra::crs(img_terra) <- "EPSG:3857"
terra::plotRGB(img_terra)
mapview::mapview(img_terra)
```


We can put that logic into a couple of functions: one that takes the converts a location to tile numbers, and one that downloads a tile and sets the extent with `terra`.

```{r}
#| label: download-tiles
tile_terra_zxy <- function(
    base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North",
    z,
    x,
    y
  ) {
    u = glue::glue("{base_url}/{z}/{x}/{y}.png")
    r = suppressWarnings(terra::rast(u))

    # NLS tiles are paletted PNGs (single band + color table). Convert to RGB so
    # interactive viewers (e.g. mapview) render the colors correctly.
    if (terra::nlyr(r) == 1 && terra::has.colors(r)) {
      ct <- terra::coltab(r)[[1]]
      rR <- terra::subst(r, ct$value, ct$red)
      rG <- terra::subst(r, ct$value, ct$green)
      rB <- terra::subst(r, ct$value, ct$blue)
      r <- c(rR, rG, rB)
      terra::RGB(r) <- 1:3
    }
    
    max_ext <- 20037508.34
    tile_size <- (2 * max_ext) / (2^z)
    
    xmin <- -max_ext + (x * tile_size)
    xmax <- -max_ext + ((x + 1) * tile_size)
    ymax <- max_ext - (y * tile_size)
    ymin <- max_ext - ((y + 1) * tile_size)
    
    terra::ext(r) <- c(xmin, xmax, ymin, ymax)
    terra::crs(r) <- "EPSG:3857"
    return(r)
}
tile_coords_to_xy <- function(lon, lat, z, scheme = c("xyz", "tms")) {
  scheme <- match.arg(scheme)
  stopifnot(is.finite(lon), is.finite(lat), is.finite(z))

  n <- 2^z

  # Web Mercator latitude limit (prevents Inf from tan/log near the poles)
  lat <- max(min(lat, 85.05112878), -85.05112878)
  lat_rad <- lat * pi / 180

  x_tile <- floor((lon + 180) / 360 * n)
  y_tile <- floor((1 - log(tan(lat_rad) + 1 / cos(lat_rad)) / pi) / 2 * n)

  # Clamp to valid range [0, n - 1]
  x_tile <- max(min(x_tile, n - 1), 0)
  y_tile <- max(min(y_tile, n - 1), 0)

  if (scheme == "tms") {
    y_tile <- (n - 1) - y_tile
  }

  c(x = x_tile, y = y_tile)
}

# Helper: get lon/lat for a tile (defaults to tile center)
tile_xy_to_lonlat <- function(x, y, z, scheme = c("xyz", "tms"), offset = 0.5) {
  scheme <- match.arg(scheme)
  stopifnot(is.finite(x), is.finite(y), is.finite(z))
  stopifnot(is.finite(offset))

  n <- 2^z

  if (scheme == "tms") {
    y <- (n - 1) - y
  }

  lon <- ((x + offset) / n) * 360 - 180
  lat_rad <- atan(sinh(pi * (1 - 2 * (y + offset) / n)))
  lat <- lat_rad * 180 / pi

  c(lon = lon, lat = lat)
}
tile_terra <- function(
    base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North",
    z,
    lon,
    lat
  ) {
    coords = tile_coords_to_xy(lon, lat, z)
    return(tile_terra_zxy(base_url, z, coords["x"], coords["y"]))
}
# Tests:
l1 = stplanr::geo_code("leeds town hall")
# The URL has been verified 
# Test tile_coords_to_xy deterministically using the center of the expected tile.
# (Rounded geocoder coordinates can land in a neighbouring tile at high zoom.)
l1_sf = sf::st_as_sf(
  data.frame(id = 1, lon = l1[1], lat = l1[2]),
  coords = c("lon", "lat"),
  crs = 4326
)
mapview::mapview(l1_sf)
# Compare: geo-coded lon/lat may not return the same z=20 tile if rounded.
tile_coords_to_xy(lon = l1[1], lat = l1[2], z = 20)
# Try downloading tile
tile1 = tile_terra(z = 20, lon = l1[1], lat = l1[2])
mapview::mapview(tile1)

l2 = stplanr::geo_code("hyde park corner leeds")
# [1] -1.561482 53.814711
tile2 = tile_terra(z = 20, lon = l2[1], lat = l2[2])
mapview::mapview(tile2)
```

# Calculate tile ranges for Leeds

```{r}
base_url <- "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North"
z <- 19
n_tiles <- 3

# Pick a small set of tiles near Hyde Park (rather than iterating a whole bounding box)
hyde_park <- c(lon = -1.56499, lat = 53.80022)
hyde_park_sf = sf::st_as_sf(
  data.frame(id = 1, lon = hyde_park["lon"], lat = hyde_park["lat"]),
  coords = c("lon", "lat"),
  crs = 4326
)
mapview::mapview(hyde_park_sf)
xy0 <- tile_coords_to_xy(hyde_park["lon"], hyde_park["lat"], z = z, scheme = "xyz")
x0 <- as.integer(xy0["x"])
y0 <- as.integer(xy0["y"])

# Choose tiles near Hyde Park.
# For very small n_tiles, prefer a contiguous strip (avoids a "missing quadrant" in a 2x2).
if (n_tiles <= 3) {
  offsets <- data.frame(
    dx = c(0, -1, 1)[seq_len(n_tiles)],
    dy = 0
  )
} else {
  side <- ceiling(sqrt(n_tiles))
  dx_range <- (-floor(side / 2)):(ceiling(side / 2) - 1)
  dy_range <- (-floor(side / 2)):(ceiling(side / 2) - 1)
  offsets <- expand.grid(dx = dx_range, dy = dy_range)
  offsets <- offsets[order(offsets$dx^2 + offsets$dy^2, abs(offsets$dx), abs(offsets$dy)), ]
  offsets <- head(offsets, n_tiles)
}

tiles <- transform(offsets, x = x0 + dx, y = y0 + dy)[, c("x", "y")]

r_list <- Map(
  function(x, y) tile_terra_zxy(base_url = base_url, z = z, x = x, y = y),
  tiles$x,
  tiles$y
)

leeds_tiles <- terra::merge(terra::sprc(r_list))
leeds_tiles_bn <- terra::project(leeds_tiles, "EPSG:27700")
mapview::mapview(leeds_tiles_bn)
terra::writeRaster(leeds_tiles_bn, "leeds_townplan.tif", overwrite = TRUE)
terra::plotRGB(leeds_tiles_bn)
```

The general pattern is: https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png

You can copy-paste that URL into QGIS 'XYZ Tiles' to access the tiles directly as shown below:

![](images/paste-1.png)

<!-- You can download the tiles using R as follows: -->

```{r}


```

```{r}
#| eval: false
# Note: failed
library(maptiles)
# Define the tile provider
nls_provider <- create_provider(
  name = "NLS_Town_Plans",
  url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/{z}/{x}/{y}.png",
  citation = "National Library of Scotland"
)
central_leeds = leeds_boundary |>
  st_transform(27700) 

mapview::mapview(central_leeds)

# Get tiles
leeds_tiles <- get_tiles(
  x = central_leeds, 
  provider = nls_provider, 
  zoom = 11,
  crop = TRUE,
  cachedir = "./tiles"
)
list.files("./tiles")
# Plot tiles
plot_tiles(leeds_tiles)
```

You can also use the `ceramic` package to download tiles:

```{r}
#| label: ceramic-tiles
#| eval: false
library(ceramic)

# Get tiles for Leeds boundary
# Note: This requires a Mapbox API key to be set in the environment variable MAPBOX_API_KEY
# Sys.setenv(MAPBOX_API_KEY = "your_key_here")

# cc_location automatically selects a zoom level based on the extent
# We use the leeds_boundary object defined earlier
leeds_tiles_ceramic <- cc_location(leeds_boundary)

# Plot
if(requireNamespace("terra", quietly = TRUE)) {
  terra::plotRGB(leeds_tiles_ceramic)
  plot(st_geometry(leeds_boundary), add = TRUE, border = "red")
}

tiles = read_tiles(
  x = central_leeds,
  base_url = "https://mapseries-tilesets.s3.amazonaws.com/os/town-england/North/",
  zoom = 19
)
```

### Extracting tram network from image

The following Python code processes the image `images/paste-2.png` to extract the Leeds tram network lines (purple), skeletonizes them, and converts the result to LineStrings.

```{python}
#| label: extract-tram-network
#| eval: false
import cv2
import numpy as np
from skimage.morphology import skeletonize
from shapely.geometry import LineString
import geopandas as gpd
import matplotlib.pyplot as plt

# Load the image
image_path = 'images/paste-2.png'
img = cv2.imread(image_path)

if img is not None:
    # Convert to HSV color space
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # Define color range for the Leeds tram network (purple/blue lines)
    # Note: These values are approximate and may need tuning based on the specific image
    # HSV range: Hue [0, 179], Saturation [0, 255], Value [0, 255]
    # Purple is roughly around 130-160 in OpenCV's Hue scale
    lower_purple = np.array([120, 50, 50])
    upper_purple = np.array([170, 255, 255])

    # Create a mask
    mask = cv2.inRange(hsv, lower_purple, upper_purple)

    # Skeletonize the mask (requires boolean input)
    # We divide by 255 to get 0/1 values
    skeleton = skeletonize(mask // 255)

    # Convert skeleton to vector representation (LineStrings)
    # This is a simplified approach using contours
    contours, _ = cv2.findContours(skeleton.astype(np.uint8), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

    lines = []
    for cnt in contours:
        # Contours are arrays of points (x, y)
        # We need at least 2 points to form a LineString
        if len(cnt) >= 2:
            points = cnt.squeeze().tolist()
            # Handle case where squeeze results in 1D array if only 1 point (though len check handles most)
            if isinstance(points, list) and len(points) >= 2 and isinstance(points[0], list):
                 lines.append(LineString(points))
            elif isinstance(points, list) and len(points) >= 2 and isinstance(points[0], (int, float)):
                 # Case with 2 points, squeeze might return list of lists or flat list depending on shape
                 # cnt shape is (N, 1, 2). squeeze -> (N, 2).
                 # If N=2, squeeze -> (2, 2).
                 lines.append(LineString(points))

    # Create a GeoDataFrame
    gdf = gpd.GeoDataFrame(geometry=lines)

    # Plotting for verification
    fig, ax = plt.subplots(1, 2, figsize=(12, 6))
    ax[0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    ax[0].set_title('Original Image')
    ax[1].imshow(skeleton, cmap='gray')
    ax[1].set_title('Skeletonized Network')
    plt.show()

    # Save to file (optional)
    # gdf.to_file("leeds_tram_skeleton.geojson", driver="GeoJSON")
else:
    print(f"Image not found at {image_path}")
```

## Research

-   Compare with historic economic and usage data
-   ...